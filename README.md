# C语言入门笔记

## 分支结构

>else和if的匹配规则：else与最靠近它的、没有与别的else匹配过的if相匹配

## 循环结构

```c
do{
    ...
}while(...);
```

>注意`while(...)`后面的<mark>**;**</mark>

`break`用来结束循环和跳出switch；`continue`用来继续下一次循环，***不适用于switch***

## 函数

函数定义：

```c
函数类型 函数名(形式参数名称)   /*函数首部*/
{
    函数实现过程                /*函数体*/
}
```

<mark>**任何C程序执行，首先从主函数main()开始**</mark>，如果遇到某个函数调用，主函数被暂停执行，转而执行相应的函数，该函数执行完后将返回主函数，然后再从原先暂停的位置继续执行

函数的调用形式:`函数名(实际参数表);`

C语言规定，函数参数传递是单向的值传递

return语句只能返回一个值

函数原型申明：

```c
函数类型 函数名(参数表);
````

注意，函数申明(<mark>**是一条C语句**</mark>)与函数定义中的函数首部相近，最大的区别是以<mark>**;**</mark>结束，其次，函数声明可以省去形参的变量名称

如果在函数调用前既不定义也不申明，则编译会报错

>函数类型省略时，函数类型被默认定义为int

## 局部变量和全局变量

C语言中把定义在函数内部的变量成为局部变量，局部变量的有效作用范围局限于所在的函数内部，形参是局部变量，使用局部变量可以避免各个函数之间的变量互相干扰

C语言还允许定义做用于复合语句中的局部变量，其有效范围被局限于复合语句内，一般用作小范围的临时变量

>局部变量一般定义在函数或复合语句的开始处，标准C规定其不能定义在中间位置

全局变量只要定义位置不在函数内，它可以定义在程序的头部，也可以定义在两个函数的中间和程序尾部

>变量同名时，作用域最小的变量被使用

自动变量的定义形式时：

```c
auto 类型名 变量表;
```

*局部变量一般不做说明都是自动变量*

***变量存储的内存分布***

|动态存储区|函数变量|
|:---:|:---:|
|静态存储区|全局变量|
||静态局部变量|

>动态存储区是使用<mark>堆栈</mark>来管理的，静态存储区中的变量若未赋初值，则**系统将自动赋值为0**

***静态局部变量作用域与自动局部变量一致，生命周期与全局变量一致***，且不会被再次初始化(赋初值)

静态局部变量定义格式：

```c
static 类型名 变量表
```

## 数据类型和表达式

教材中给出的部分机器和编译器中的数据类型及长度，仅作参考

|类别|名称|类型名|数据长度|取值范围|
|:---:|:---:|:---:|:---:|:---:|
||[有符号]整形|int|32bit|-2147483648~214783647|
||[有符号]短整型|short[ int]|16bit|-32768~32767|
|整行|[有符号]长整型|long[ int]|32bit|-2147483648~214783647|
||无符号整型|unsigned[ int]|32bit|0~4284967285|
||无符号短整型|unsigned short [ int]|16bit|0~65535|
||无符号长整形|unsigned long [ int]|32bit|0~4294967295|
|字符型|字符型|[unsigned ]char|8bit|0~255|
|实型|单精度浮点型|float|32bit|约&plusmn;(10<sup>-38</sup>~10<sup>38</sup>)|
|(浮点数)|双精度浮点型|double|64bit|约&plusmn;(10<sup>-308</sup>~10<sup>308</sup>)|

>C语言并未规定各类整形数据的长度，只要求short型不长于int型，long型不短于int型

**整数的表示：**

八进制：0开头  
十六进制：0x或0X开头，分别对应字母的大小写

**整数的类型：**

后缀：  
long：l、L  
unsigned：u、U  
unsigned long：lu、LU

转义字符：

|字符|含义|
|:---:|:---:|
|\a|声音警铃|
|\b|退格|
|\f|表单|
|\r|回车|
|\n|换行|
|\t|水平制表|
|\v|垂直制表|
|\\\\ |反斜杠|
|\\"|双引号|
|\\'|单引号|
|\?|问号|
|\0|空字符|
|\ddd|1~3位八进制整数所代表的字符|
|\xhh|1~2位十六进制整数所代表的字符|

>就浮点型数据而言，数值精度和取值范围是两个不同的概念，运算中可能会损失有效数字，降低精度  
<mark>***实型常量都是双精度浮点型***</mark>  
科学计数法表示实型常数：&plusmn;123<sup>-456</sup>可以表示成&plusmn;1.23E-454；&plusmn;0.123<sup>456</sup>可以表示成&plusmn;1.23e+457

***数据的输入和输出***

|数据类型||输入输出类型||
|:---:|:---:|:---:|:---:|
||十进制|八进制|十六进制|
|int|%d|%o|%x|
|long|%l|%lo|%lx|
|unsigned|%u|%o|%x|
|unsigned long|%lu|%lo|%lx|

|函数|数据类型|格式|含义|
|:---:|:---:|:---:|:---:|
|printf|float|%f|以小数形式输出浮点数（保留6位小数）|
||double|%e|以指数形式输出浮点数（小数点前有且仅有一位非零的数字）|
|scanf|float|%f|以小数形式输入一个单精度浮点数|
|||%e|以指数形式输入一个单精度浮点数|
||double|%lf|以小数形式输入一个双精度浮点数|
|||%le|以指数形式输入一个双精度浮点数|

### 类型转换

自动类型转换：

```c
double<-float
^
|
unsigned long<-long
^
|
unsigned<-unsigned short
^
|
int<-char,short
```

### 表达式

#### 运算符优先级及结合方式

|优先级|运算符|名称|特征|结合方向|
|:---:|:---:|:---:|:---:|:---:|
|1|( )[] -> .|圆括号 下标 指针引用结构体成员 取结构变量成员|初等运算|从左到右|
|2|! <mark>~</mark> + - (类型名) * & == -- sizeof|逻辑非 按位取反 正号 负号 类型强制转换 取指针内容 取地址 自增 自减 长度运算符|单目运算|从右到左|
|3|* / %|相乘 相除 取余|算术运算|从左到右|
|4|+ -|相加 相减|算术运算|从左到右|
|5|<< >>|左移 右移|移位运算|从左到右|
|6|> < >= <=|大于 小于 大于或等于 小于或等于|关系运算|从左到右|
|7|== !=|等于 不等于||从左到右|
|8|&|按位与|位逻辑运算|从左到右|
|9|^|按位异或|位逻辑运算|从左到右|
|10|\||按位或|位逻辑运算|从左到右|
|11|&&|逻辑与|逻辑运算|从左到右|
|12|\|\||逻辑或|逻辑运算|从左到右|
|13|?:|条件运算|三目运算|从右到左|
|14|= += -= *= /= %= &= ^= =  >>= <<=|赋值运算||从右到左|
|15|,|逗号运算||从左到右|

>思考：表达式(n>0)?2.9:1的类型？

<details>
  <summary>答案</summary>
  <u>不管n是否大于0，根据自动类型转换规则，表达式的值一定为double(浮点常数)</u>
</details>

## 数组

>C语言规定数组名表示该数组所分配连续内存空间的弟也各单元的地址，即首地址，**<mark>因此数组名是一个地址常量，不允许改变</mark>**

虽然C语言规定，只有静态存储的数组才能初始化，但一般的C编译系统都允许对动态存储的数组赋初值

>***在C语言中，声明多维数组时，只有第一维（最左边）的长度可以省略，其他维度必须明确指定大小。这是因为编译器需要知道每个子数组的长度来计算内存布局（行优先存储）。***

## 指针

>思考：为什么scanf接收folat和double类型的变量要加&，且要将两种类型用%(l)f区分开来，而printf则不用

<details>
  <summary>答案</summary>
  <u>scanf接受变量使用的是void *类型的指针(能与任何无修饰词的指针相互转换)，需要借助参数表的%(l)f来确定所指向的变量的存储形式</u>
</details>

NULL定义在stdio.h中，值为0

### 引用调用(Call by Reference)

在C语言函数调用中，实参和形参之间的数据传递是单向的“值传递”的方式，调用函数不能改变实参变量的值，但可以改变实参指针变量所指向的变量的值，这样的机制被称为引用调用

>p和q是指向数组元素的两个指针，那么p-q产生一个int型的值，该表示在p和q之间的数组元素的个数

><u>***分治法***</u>  
二分法查找就是一种分治法的思想，运用分治法进行排序，可以有两种思路，分别是快速排序法(Qiuck Sorting)和归并排序法(Merge Sorting)

### 字符串和字符指针

字符串常量实质上是一个指向该字符串首字符的指针常量

### 常用字符串处理函数

#### 字符串的输入和输出

1. scanf(格式控制字符串，输入参数表)，该函数与空格或回车输入结束，自动填充`'\0'`
2. printf(格式控制字符串，输入参数表)输出遇`'\0'`结束
3. gets()遇回车结束，自动填充`'\0'`，成功返回字符串地址，失败返回`NULL`
4. puts()<mark>输出时遇`'\0'`自动将其转换为`'\n'`</mark>，成功返回`'\n'`，失败返回`EOF`

#### 字符串的赋值、连接和比较及字符串的长度

1. `char *strcpy(char *s1,char *s2)`
2. `strcat(s1,s2)`
3. `strcmp(s1,s2)`若s1==s2，返回0；若s1>s2，返回一个正数；若s1<s2，返回一个负数
4. `strlen()`返回字符串有效字符的个数

### 用指针实现内存动态分配

1. `void *malloc(unsigned size)`，在内存的动态存储区中分配一连续空间，长度为size，<mark>不进行初始化</mark>，若申请成功则返回指向所分配内存空间的起始地址的指针；若申请内存空间失败，则返回`NULL(0)`
2. `void *clloc(unsigned n,unsigned size)`，在内存的动态存储区中分配n个连续空间，每一内存空间的长度为size，<mark>且初始化为0</mark>，若申请成功则返回指向所分配内存空间的起始地址的指针；若申请内存空间失败，则返回`NULL(0)`
3. `void free(void ptr)`释放指针所指向的内存空间(指向NULL则无行为)
4. `void *realloc(void *ptr,unsigned size)`更改以前的储存分配，ptr必须是以前通过动态内存分配的得到的指针；失败返回`NULL(0)`，成功则返回一片内存放大小为size的区块，并保证该块的内容与原块一致

## 结构

结构类型定义的一般形式:
```c
struct 结构名{
  类型名 结构成员1;
  类型名 结构成员2;
  ...
  类型名 结构成员n;
};
```

>关键字struct和它后面的结构名一起组成一个新的数据结构类型名，<mark>结构的定义以分号结束，这是因为C语言把结构的定义看作一条语句</mark>

>在定义嵌套的结构类型时，必须先定义成员的结构类型，再定义主结构类型

### 结构变量的定义和初始化：

1. 单独定义  
   `struct 结构名 变量名;`
2. 混合定义  
   ```c
   struct 结构名{
      类型名 结构成员1;
      结构名 结构成员2;
      ...
      结构名 结构成员n;
   }结构变量名表;
   ```
3. 无类型名定义(失去了类型名，无法再直接定义相关变量)
      ```c
   struct{
      类型名 结构成员1;
      结构名 结构成员2;
      ...
      结构名 结构成员n;
   }结构变量名表;
   ```

结构变量的初始化：

`struct 结构名 变量名={初始化列表};`



>关键字struct和结构名students必须联合使用，因为他们合起来表示一个数据类型名

### 结构指针

通过结构指针变量简介访问它所指向的结构变量的各个成员：

1. `(*指针变量名).结构成员`
2. `指针变量名->结构成员`

## 函数与程序结构

### 递归程序设计

1. 递归出口：及递归地结束条件，到何时不再递归调用下去
2. 递归式子：递归的表达式

### 宏基本定义

宏定义的格式：

```c
#define 宏名 宏定义字符串
```

宏定义在编译预处理中起作用，进行文本替换，不是真正的C语句，<mark>行尾无需跟分号</mark>

>如果红第一字符串后面跟分号，编译预处理时会把分号也作为宏替换的内容  
#define最后跟的`"\"`表示该行还未结束，与下一行合起来成为完整一行  
C语言允许宏嵌套定义

### 文件包含

1. `#include <需包含文件名>`编译器直接到C系统中设置好的include文件夹中把指定的文件包含进来
2. `#include "需包含文件名"`<mark>编译器首先到当前工作文件夹寻找被包含文件</mark>，必要时可以在文件名前加上所在的路径

### 编译预处理

>编译预处理功能主要包括文件包含(#include)、宏定义(#define)和条件编译。

#### 条件编译

条件编译广泛运用于商业软件，可以为一个程序提供多个版本，不同用户使用不同版本，运行不同的程序功能：

```c
#define FLAG 1
#if FLAG
  程序段1
#else
  程序段2
#endif
```

>注意：<mark>#if的条件只能是宏名或常量表达式</mark>，不能是程序表达式，因为在编译预处理时是无法计算表达式的，必须在程序运行时才能做计算

### 文件模块间的通信

#### 外部变量

>全局变量只能在某个模块中定义一次，如果其他模块要使用该全局变量，需要通过外部变量的申明，当程序连接时会统一指向全局变量定义的模块

外部变量申明的格式为：

```c
extern 类型名 变量名表;
```

#### 静态全局变量

>C语言的静态局部变量可以把变量的作用范围仅限于当前的文件模块中，即使其他文件模块使用外部变量申明，也不能使用该变量

#### 函数与程序文件模块

>一般情况下，关键字extern可以省略，编译器如果在当前文件模块中找不到函数定义体，自动认为该函数是外部函数

外部函数申明：

```c
extern 函数类型 函数名(参数表说明);
```

静态函数定义格式：

```c
static 函数类型 函数名(参数表说明);
```

## 指针进阶

### 指针数组和数组指针

指针数组：

```c
类型名 *数组名[数组长度];
```

数组指针：

```c
类型名 (*指针名)[数组长度];
```

### 产生随机数

>一般来说，先用`srand(unsigned int(time(NULL)))`，将种子与时钟相关联，然后使用`rand()%n`来取得0~n-1的随机数  
其中，srand和rand定义在<stdlib.h>中，time定义在<time.h>中

### 命令行参数

>在C语言程序中，主函数main()可以有两个参数，用于接收命令行参数(Command Line Parameter)。带有参数的main()习惯上书写为：

```c
int main(int argc,char *argv[]){
  ...
}
```

第一个参数argc(argument count)接收命令行参数(<mark>包括命令</mark>)的个数；第二个参数argv(argument vector)接收一字符串常量形式存放的命令行参数(<mark>包括命令本身也作为一个参数</mark>)，其中，argv[0]指向命令，argv[1]指向第一个命令行参……argv[argc-1]指向最后一个命令行参数

### 函数指针

函数指针的定义：

```c
类型名 (* 函数名)(参数类型表);
```

eg：

```c
int *(*(* fptr)(int x))(int a,int b);
```

<details>
  <summary>
  答案
  </summary>
  fptr是一个函数指针，它指向的函数参数列表为(int x)，返回值也是一个函数指针
  ，返回的函数指针指向的是一个参数列表为(int a,int b)，返回值为int *(指针)类型的函数
</details>

### 链表

链表是使用结构构造的结构体，其中最具链表特色的是链表中包含的指向下一个链表结构的指针，这称为结构的递归定义，链表变量一般用指针head表示，用来存放链表首节点的地址，链表中指向下一个结点的指针一般定义为next，最后一个结点的next应指向NULL

## 文件  

### 文本文件和二进制文件

C语言源程序是文本文件，目标文件和可执行文件是二进制文件

### 缓冲文件系统

在UNIX操作系统中，用缓冲文件系统来处理文本文件，用非缓冲文件系统来处理二进制文件，而标准ANSI C中规定只采用缓冲文件系统

缓冲文件系统的文件缓冲区大小一般为一扇区(<mark>512B</mark>)

自定义类型(别名，一般用大写)的一般形式：<mark>typedef <已有类型名> <新类型名>;</mark>  
例如:  
>typedef int (*PTR)[5];  
PTR p;  
等价于:  
int (*p)[5];

FILE的内部结构(定义在<stdio.h>中)：

```  
typedef struct {
    short level;            //缓冲区使用量  
    unsigned flag;          //文件状态标志  
    char fd;                //文件描述符  
    short bsize;            //缓冲区大小  
    unsigned char *buffer;  //文件缓冲区的首地址
    unsigned char *curp;    //指向文件缓冲区的工作指针
    unsigned char hold;     //其他信息
    unsigned istemp;        
    short token;
} FILE;    
```

定义文件指针：`FILE *fp;`

>文件指针不能进行fp++或*fp等操作，<mark>fp++将意味着指向下一个FILE结构</mark>(如果存在)。

通过fp->curp可以指示文件缓冲区中数据据存取的位置，但文件操作具有顺序性的特点，每次操作后fp->curp会发生改变，改变隐含在文件读写操作中，不需要在编程时写上fp->curp++，类似这样的操作将由操作系统在文件读写时自动完成

### 文件控制模块

>操作系统通过文件控制块FCB(File Control Block)实现文件缓冲区与磁盘文件之间的处理。文件缓冲块包括：文件属性、文件名、驱动器号、拓展名、文件长度以及文件记录状态等信息。

### 打开和关闭文件

打开文件 <mark>(FILE *)fopen("文件名","打开方式")</mark>

`if((fp=fopen("文件名","打开方式"))!=NULL);`

返回值：成功则返回包含文件缓冲区的信息的FILE结构地址，失败则返回NULL

>C语言认为`\`是转义字符，因此要用`\\`来表示windows路径;用`/`来表示类UNIX系统的路径

|文本文件(ASCII)||二进制文件||
|:---:|:---:|:---:|:---:|
|使用方式|含义|使用方式|含义|
|"r"|打开文本文件进行只读|"rb"|打开二进制文件进行只读|
|"w"|建立新文本文件进行只读|"wb"|建立新二进制文件进行只读|
|"a"|打开文本文件进行追读|"ab"|打开二进制文件进行追读|
|"r+"|打开文本文件进行读/写|"rb+"|打开二进制文件进行读/写|
|"w+"|建立新文本文件进行读/写|"wb+"|建立新二进制文件进行读/写|
|"a+"|打开文本文件进行读/写/追加|"ab+"|打开二进制文件进行读/写/追加|

C语言允许同时打开多个文件，不同文件采用不同文件指针指示，但不允许同一个文件再关闭前被再次打开

关闭文件<mark>int</mark> fclose(文件指针);注意:<mark>0</mark>表示正常关闭文件

### 文件读写

* 文本模式：

1. `ch=fgetc(fp);`
2. `fpuc(ch,fp);`函数返回值若写文件成功为ch，若写文件失败为<mark>EOF</mark>
3. `fputs(s,fp);`函数返回值若写文件成功为所写入字符串的最后一个字符(`\0`不写入文件中)，若写文件失败为<mark>EOF</mark>
4. `fgets(s,n,fp);`n是指定读入的个数(第n个字符自动添加为`\0`)，当读取字符达到指定个数或接收到换行符(保留换行符)或接受到文件结束标志EOF(不保留EOF)时，将自动田间`\0`；函数返回值若读取文件成功为读取的字符串，若读取文件失败为<mark>NULL</mark>
5. `fscanf(文件指针,格式字符表,输入表);`
6. `fprintf(文件指针,格式字符表,输出表);`

* 二进制文件读写

1. `fread(buffer,size,count,fp);`
2. `fwrite(buffer,size,count,fp);`

* 其他相关函数

1. `rewind(fp);`重定位文件首函数
2. `fseek(fp,offset,frem);`offset表示移动偏移量，可为负值，它应该是long型数据，<mark>使用常量时，应加上后缀`L`</mark>；from即起点，位置可取三种：SEEK_SET(0)(文件首部)，SEEK_CUR(1)(当前位置)，SEEK_END(2)(文件尾部)
3. `ftell(fp);`获取当前文件读写位置指针，<mark>返回值为相对于文件首部的位移量(字节数)，此函数出错时，返回值为-1L</mark>
4. `feof(fp);`用于判断指针是否已经读写到了文件末尾，<mark>该函数成功返回1表示已经到了文件结束位置，0表示文件未结束</mark>
5. `feeror(fp);`用来检查文件在用各种输入输出函数进行读写时是否出错，返回值为0，表示为出错，否则表示出错
6. `clearerr(fp);`用来清理出错标志和文件结束标志，使它们为0

## 附录

* C语言关键字

|1|2|3|4|5|6|7|8|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|auto|break|case|char|const|continue|default|do|
|double|else|enum|extern|float|for|goto|if||
|int|long|register|return|short|signed|sizeof|static|
|struct|switch|typedef|union|unsigned|void|volatile|while|

* 标识符

C语言的标识符由字母、数字和下划线组成，其中第一个字符必须是字母或下划线，且C语言区分大小写

* 注释

1. 当行注释：`//...`
2. 多行注释：`/*...*/`

* break语句

break语句只能用于for、while、do或者switch语句内部

* continue语句

continue语句只能用于循环语句内部

* goto语句

goto 标号;

一般不提倡使用goto语句

* 联合变量定义和初始化

联合的一般声明形式：

```c
union 联合名{
  成员声明
  成员声明
  ...
}变量列表;
```

在定义联合之后声明联合变量：

`union 联合名 变量列表;`

* 枚举变量定义和初始化

枚举的一般声明形式：

```c
enum 枚举名{枚举值1,枚举值2,...}变量列表;
```

在定义枚举之后声明枚举变量：

`enum 枚举名 变量列表;`

>某个枚举变量的值只能是定义是列出的枚举值之一

* 存储类型及作用域

C语言一共有4中存储类型：auto、static、extern、register

* 函数

>在函数定义的前面可以加上关键字inline，该关键字指示编译器将程序的实际代码插到适当的位置，而不是去调用函数，这样可以获得更快的执行速度

* 编译预处理

预处理器一般完成如下几类工作：

1. 将所有以反斜杠`\`结尾的行与后面一行合并为同一行
2. 将程序分解为记号流
3. 删除所有的注释，并用单个空格替换它们
4. 处理预处理指令并展开所有宏

>所有预处理指令都必须以#开始，在#后可以有一个或者多个空格和tab字符

#define指令的一种常见形式：

`#define 宏名(参数1,参数2,...,参数n)宏定义字符串`

#if指令：

```c
#if 常量表达式1
  程序段1
#elif 常量表达式2
  程序段2
  ...
#else
  程序段n
#endif
```

#ifdef指令：

```c
#ifdef 标识符
  程序段
#endif
```

如果标识符代表的宏已经被定义过了(可能是通过#define语句，也可能是通过命令行上的-D选项)，#ifdef和#endif之间的语句将被编译，否则，这些语句将被忽略。如同#if指令一样，#ifdef指令后面也可以有#elif指令和#else指令

与#ifdef相对应的还有#ifndef指令，意义正好和#ifdef相反

一个被#include指令引入的文件中，还可以包含一个#include指令

>C语言的预处理指令还有#line、#error和#progma，这些指令主要用于构造C程序

* 数学函数

#include<math.h>

|函数名|函数定义格式|函数功能|返回值|说明|
|:---:|:---:|:---:|:---:|:---:|
|abs|`int abs(int x)`|求整型数x的绝对值|计算结果|函数说明在stdlib.h中|
|fabs|`double fabs(double x)`|求x的绝对值|计算结果||
|sqrt|`double sqrt(double x)`|计算x的平方根|计算结果|要求x>=0|
|exp|`double exp(double x)`|计算e<sup>x</sup>|计算结果|e为2.718...|
|pow|`double pow(double x,double y)`|计算x<sup>y</sup>|计算结果||
|log|`double log(double x)`|求lnx|计算结果|自然对数|
|log10|`double log10(double x)`|求log<sub>10</sub>x|计算结果||
|ceil|`double ceil(double x)`|求不大于x的最小整数|double类型||
|floor|`double floor(double x)`|求小于x的最大整数|double类型||
|fmod|`double fmod(double x,double y)`|求x/y的余数|double类型||
|modf|`double modf(double x,double *ptr)`|把x分解，整数部分存入*ptr|x的小数部分||
|sin|`double sin(double x)`|计算sin(x)|[-1,1]|x为弧度值|
|cos|`double cos(double x)`|计算cos(x)|[-1,1]|x为弧度值|
|tan|`double tan(double x)`|计算tan(x)|计算结果|x为弧度值|
|asin|`double asin(double x)`|计算sin<sup>-1</sup>(x)|[0,&pi;]|x&isin;[-1,1]|
|acos|`double acos(double x)`|计算cos<sup>-1</sup>(x)|[0,&pi;]|x&isin;[-1,1]|
|atan|`double atan(double x)`|计算tan<sup>-1</sup>(x)|[-&pi;/2,&pi;/2]||
|atan2|`double atan2(double x,double y)`|计算tan<sup>-1</sup>(x/y)|[-&pi;/2,&pi;/2]||
|sinh|`double sinh(double x)`|计算sinh(x)|计算结果|x为弧度值|
|cosh|`double cosh(double x)`|计算cosh(x)|计算结果|x为弧度值|
|tanh|`double tanh(double x)`|计算tanh(x)|计算结果|x为弧度值|

* 输入输出函数

1. 格式化输入输出函数

|函数名|函数定义格式|函数功能|返回值|
|:---:|:---:|:---:|:---:|
|printf|`int printf(char *format,输出表)`|按串format给定输出格式，把输出表各表达式的值，输出到标准输出文件|成功：输出字符数 失败：EOF|
|scanf|`int scanf(char *format,输出项地址列表)`|按串format给定输出格式，从标准输入文件读入数据，存入各输入项地址列表指定的存储单元|成功：输入数据的个数 失败：EOF|
|sprintf|`int sprintf(char *s,char *format,输出表)`|功能类似printf()函数，单输出目标为字符串s|成功：输出字符数  失败：EOF|
|sscanf|`int sscanf(char *s,char *format,输入项地址表)`|功能类似scanf()函数，但输入源为字符串s|成功：输入数据的个数 失败：EOF|

2. 字符(串)输入输出函数

|函数名|函数定义格式|函数功能|返回值|
|:---:|:---:|:---:|:---:|
|getchar|`int getchar()`|从标准输入文件读入一个字符|字符ASCII值或EOF|
|putchar|`int putchar(ch)`|向标准输出文件输出字符ch|成功：ch  失败：EOF|
|gets|`char *get(char *s)`|从标准输入文件读入一个字符串到字符串s，输入字符串以回车结束|成功：s  失败：NULL|
|puts|`int puts(char *s)`|把字符串s输出到标注输出文件，'`\0`'转换为'`\n`'输出|成功：换行符  失败：EOF|
|fgetc|`int fgetc(FILE *fp)`|从fp所指文件中读取一个字符|成功：所取字符  失败：EOF|
|fputc|`int fpuc(char ch,FILE *fp)`|将字符ch输出到fp所指向的文件|成功：ch 失败：EOF|
|fgets|`char *fgets(char *s,int n,FILE *fp)`|从fp所指文件最多读取n-1个字符(遇'`\n`'、'^z`终止)到字符串s中|成功：s 失败：NULL|
|fputs|`int *fputs(char *s,FILE *fp)`|将字符串s输出到fp所指向文件|成功：s的末字符 失败：0|

3. 文件操作函数

|函数名|函数定义格式|函数功能|返回值|
|:---:|:---:|:---:|:---:|
|fopen|`FILE *fopen(char *fname,char *mode)`|以mode方式打开文件fname|成功：文件指针 失败：NULL|
|fclose|`int fclose(FILE *fp)`|关闭fp所指文件|成功：0 失败：非0|
|feof|`int feof(FILE *fp)`|检查fp所指文件是否结束|是：非0 否：0|
|fread|`int fread(T *a,long sizeof(T),unsigned int n,FILE *fp)`|从fp所指文件复制n*sizeof(T)个字节，到T类型指针变量a所指内存区域|成功：n 失败：0|
|fwrite|`int fwrite(T *a,long sizeof(T),unsigned int n,FILE *fp)`|从T类型指针变量a所指处起复制n*sizeof(T)个字节的数据，到fp所指文件|成功：n  失败：0|
|rewind|`void rewind(FILE *fp)`|移动fp所指文件读写位置到文件头||
|fseek|`int fseek(FILE *fp,long n,unsigned int posi)`|移动fp所指文件读写位置，n为移位量，posi决定起点位置|成功：0 失败：非0|
|ftell|`long ftell(FILE *fp)`|求当前读写位置到文件头的字节数|成功：所求字节数 失败：-1L(EOF)|
|remove|`int remove(char *fname)`|删除名为fname的文件|成功：0 失败：EOF|
|rename|`int rename(char *oldfname,char *newfname)`|该文件名oldfname为newfname|成功：0  失败：EOF|

* 字符判别函数

#include <ctype.h>

|函数名|函数定义格式|函数功能|返回值|
|:---:|:---:|:---:|:---:|
|isalpha|`int isalpha(char c)`|判别c是否为字母字符|是：返回非0  否：返回0|
|islower|`int islower(char c)`|判别c是否为小写字母|是：返回非0  否：返回0|
|isupper|`int isupper(char c)`|判别c是否为大写字母|是：返回非0  否：返回0|
|isdigit|`int isdigit(char c)`|判别c是否为数字字符|是：返回非0  否：返回0|
|isalnum|`int isalnum(char c)`|判别c是否为字母、数字字符|是：返回非0  否：返回0|
|isspace|`int isspace(char c)`|判别c是否为空格字符|是：返回非0  否：返回0|
|iscntrl|`int iscntrl(char c)`|判别c是否为控制字符|是：返回非0  否：返回0|
|isprint|`int isprint(char c)`|判别c是否为可打印字符|是：返回非0  否：返回0|
|ispunct|`int ispunct(char c)`|判别c是否为标点字符|是：返回非0  否：返回0|
|isgraph|`int isgraph(char c)`|判别c是否是除字母、数字、空格外的可打印字符|是：返回非0  否：返回0|
|tolower|`int tolower(char c)`|将大写字母c转换为小写字母|c对应的小写字母|
|toupper|`int toupper(char c)`|将小写字母转换为大写字母|c对应的小写字母|

* 字符串操作函数

#include <string.h>

|函数名|函数定义格式|函数功能|返回值|
|:---:|:---:|:---:|:---:|
|strcat|`char *strcat(char *s,char *t)`|把字符串t连接到s，使s成为包含s和t的结果串|字符串s|
|strcmp|`int strcmp(char *s,char *t)`|逐个比较字符串s和t中的对应字符，知道对应字符不等或比较到串尾|相等：0  不等：不相等字符的差值|
|strcpy|`char *strcpy(char *s,char *t)`|把字符串t复制到s中|字符串s|
|strlen|`unsigned int strlen(char *s)`|计算字符串s的有效长度(不包括'`\0`')|字符串长度|
|strchr|`char *strchr(char *s,char c)`|在字符串中查找字符c首次出现的地址|找到：相应地址 找不到：NULL|
|strstr|`char *strstr(char *s,char *t)`|在字符串中查找字符串t首次出现的地址|找到：相应地址 找不到：NULL|

* 数值转换函数

#include <stdlib.h>

|函数名|函数定义格式|函数功能|返回值|
|:---:|:---:|:---:|:---:|
|abs|`int abs(int x)`|求整数x的绝对值|运算结果|
|atof|`double atof(char *s)`|把字符串s转换成双精度浮点数|运算结果|
|atoi|`int atoi(char *s)`|把字符串s转换成整型数|运算结果|
|atol|`long atol(char *s)`|把字符串s转换成长整型数|运算结果|
|rand|`int rand()`|产生一个伪随机的无符号整数|伪随机数|
|srand|`void srand(unsigned int seed)`|以seed微中子(初始值)计算产生一个无符号的随机整数|随机数|

* 动态内存分配函数

#include <stdlib.h>

|函数名|函数定义格式|函数功能|返回值|
|:---:|:---:|:---:|:---:|
|calloc|`void *calloc(unsigned int n,unsigned int size)`|分配n个连续存储单元(每个单元包含size个字节)|成功：分配单元首地址 失败：NULL|
|malloc|`void *malloc(unsigned int size)`|分配size个字节的存储单元块|成功：分配单元块首地址 失败：NULL|
|free|`void free(void *p)`|释放p所指向存储单元块(必须是由动态分配函数一次性分配的全部单元)|无|
|realloc|`void *realloc(void *p,unsigned int size)`|将p所指的已分配内存单元块的大小改为size|成功：分配单元块首地址 失败：NULL|

* 过程控制函数

#include <process.h>

|函数名|函数定义格式|函数功能|返回值|
|:---:|:---:|:---:|:---:|
|exit|`void exit(int status)`|使程序执行立刻终止，并清除和关闭所有打开的文件。  status==0表示程序正常结束；status非0则表示程序存在错误执行|无|